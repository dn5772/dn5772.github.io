---
title: "외판원 문제(TSP) 해결 - 유전자 알고리즘 구현"
date: 2023-04-15
draft: false
tags: ["TSP", "외판원 문제", "유전자 알고리즘", "C++", "알고리즘", "과제"]
categories: ["summary/cesc"]
---

# 유전자 알고리즘(GA)을 이용한 TSP 최적화 구현 및 분석

**작성자**: 20202058 신대니

## 개요

C++을 사용하여 Traveling Salesman Problem(TSP)을 유전자 알고리즘(GA)으로 해결하고, 실험 과정을 통해 성능을 최적화해나가는 과정을 기록한 보고서입니다.

---

## 1. 구현 환경 및 데이터 구조

### 1.1 개발 언어 및 기본 설정

- **언어**: C++
- **거리 계산 최적화**: 도시 좌표는 2차원 벡터에 저장하되, 거리 계산 오버헤드를 줄이기 위해 `W[1000][1000]` 인접 행렬에 미리 모든 거리를 계산하여 저장해서 사용

### 1.2 Path (염색체) 클래스 구조

각 경로 후보는 Path 객체로 정의하여 관리했습니다.

**주요 멤버 변수**:
- `vector<int> x`: 경로 정보 (x[i] = j는 '도시 i에서 도시 j로 이동'을 의미)
- `double tot_cost`: 총 비용
- `int firstIndex, lastIndex`: 유망한 부분의 시작/끝 인덱스
- `double best_cost`: 유망한 부분의 비용
- `double avg`: 각 엣지의 평균 비용

**비용 계산 (cal_cost)**:
- 경로의 총 비용뿐만 아니라
- 크기가 `s`로 고정된 구간 중 **비용이 가장 작은 '유망한 부분'**도 계산

### 1.3 개체군(Population) 관리

- 염색체들은 정렬이 빈번하게 일어나므로 `list` 자료구조 사용
- 총 **N개의 염색체**를 한 세대로 유지 (실험에서 N = 20)

---

## 2. 알고리즘 상세 로직

### 2.1 초기화 (Initialization)

초기 염색체를 완전 랜덤으로 생성하지 않고, **Greedy 알고리즘을 변형**하여 최적화된 상태로 시작:

```
1. 랜덤한 도시를 시작점으로 설정
2. 현재 도시에서 가장 가까운 미방문 도시 선택
3. 이 과정을 반복하여 경로 구성
4. N개의 초기 염색체 생성
```

### 2.2 선택 (Selection)

초기: 정렬된 N개 중 상위부터 순서대로 짝 지음 (1-2, 3-4, ...)

**문제점 발생** → **개선**: 조기 수렴 현상을 해결하기 위해 N개 중 **랜덤으로 2개를 선택**하여 교차 진행

### 2.3 교차 (Crossover)

부모 Path a, b로부터 자식을 생성:

```
1. 유망한 부분 상속: 비용이 적은 쪽의 유망 구간을 자식에게 전달
2. 나머지 연결:
   - 앞으로의 경로를 간단히 비교 (3개의 엣지 확인)
   - 더 유망한 쪽을 선택
   - a, b 모두 연결된 노드 가리키면 Greedy로 가장 가까운 노드 선택
3. 비용 기준으로 평가
```

### 2.4 변이 (Mutation)

초기에는 미포함 → 성능 개선을 위해 **추가**:

```
1. 랜덤한 인덱스를 기준으로 뒤쪽 6개 인덱스를 섞음
2. 섞은 후 비용 < 원래 비용이면 업데이트
3. 100회 시도 반복
```

### 2.5 대치 (Replacement)

- 교차와 변이 후 약 1.5 * N개의 염색체 존재
- 중복된 염색체 제거
- 비용 기준으로 정렬 후 상위 N개 선택
- 가장 비용이 적은 Path를 정답으로 채택

---

## 3. 실험 과정 및 문제 해결

### 3.1 초기 버전 (Greedy + 단순 교차)

**설정**:
- 유망 부분 길이: s = 250
- 변이: 없음

**문제점**:
- 초기 설정 후 값의 변화 거의 없음
- 자식 세대가 부모보다 비용이 큼
- **조기 수렴(Premature Convergence)** 발생

### 3.2 1차 개선: 변이(Mutation) 추가

**조치**:
- s값 축소 (250 → 100)
- 6개 인덱스를 섞는 변이 연산 추가

**결과**: 개선이 미미함. 변이만으로는 교차의 한계 극복 어려움

### 3.3 2차 개선: 교차(Crossover) 로직 수정

**분석**:
- s를 대폭 축소 (100 → 10)
- 교차 자체 개선 필요

**수정 사항**:
- 유망한 부분 우선 (변경 없음)
- **길게 연결된 엣지(Long Edge) 우선 처리**
- 비용이 평균의 2배 이상이면 다른 경로 탐색
- 둘 다 막히면 Greedy

**결과**:
- Cost: 약 2800 → 2660 달성 ✓
- 일정 수준 이후 정체됨

### 3.4 3차 개선: 선택(Selection) 방식 변경

**원인 분석**:
1. 교차에서 부모보다 나은 자식이 부족
2. 순위 기반 선택으로 인한 **다양성 부족**

**조치**:
- 순위 기반 선택 → **랜덤 선택**으로 변경

**결과**:
- 최종 결과에 큰 변화 없음
- **수렴 속도 대폭 개선** ✓
- 초반 교차로 빠른 최적화, 후반 변이로 미미한 개선

---

## 4. 한계점: Long Edge 문제

### 현상

최종 결과에서 **특정 구간의 길게 연결된 선(Long Edge)**들이 관찰됨:

```
원인: 초기화 또는 교차 과정에서 Greedy 사용 시,
마지막에 남은 도시들을 연결할 때 발생
→ 주변 노드들이 이미 방문 처리됨
```

### 시도했던 해결책

- 남은 도시가 약 100개 될 때 시작점 근처로 돌아오도록 시도 → 실패
- Greedy를 최후의 수단으로 미루는 로직 강화 → 결국 마지막 단계에서 롱 엣지 발생 불가피

---

## 5. 결론

### 달성 사항

✓ 유전자 알고리즘의 핵심 단계 모두 구현 및 실험  
✓ Greedy 초기화가 완전 무작위보다 유리함을 확인  
✓ 선택 방식 변경으로 조기 수렴 해결  
✓ 변이를 통한 국소 최적해 탈출 시도

### 향후 개선 방안

1. **양방향 탐색**: 시작점을 기준으로 한 방향만 아닌, 양쪽(Start/End)에서 동시에 연결
2. **중간 지점 설정**: 양방향 탐색으로 마지막 장거리 연결 문제 완화

---

#TSP #유전자알고리즘 #외판원문제 #C++ #알고리즘